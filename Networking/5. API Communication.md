# API Communication

## Definition

API (Application Programming Interface) communication enables interaction between services, applications, or devices. 

- It defines **how data is requested, transferred, and consumed** across systems. 

- It is the backbone of **microservices, distributed systems, and clientâ€“server applications**.

- `All web services are APIs, but not all APIs are web`

![API Communication](images/api_communication.png)

- Today, over 80% of modern web applications rely on APIs to fetch data, integrate with third-party services, or enable features like login, payments, or real-time updates.

---

## Why Do We Need APIs

APIs help developers to create software programs more easily. Instead of writing complex code from scratch, they can call APIs that already provide the functions they need.

- E.g, If a developer wants to display a weather report, they can use an API to get the data instead of creating the entire system to gather weather data themselves.

## How Do APIs Work?

APIs work in a simple step-by-step process:

- **Request**: A client (user) sends a request through the API's URI (Uniform Resource Identifier).

- **Processing**: The API forwards the request to the server.

- **Response**: The server processes the request and sends the response back to the API.

- **Delivery**: The API returns the server's response to the client.

--- 

## Types of APIs

### 1. REST (Representational State Transfer)

- REST APIs work by sending requests and receiving responses, typically in JSON format, between the client and server.

![REST API](images/rest_api.png)

- A request is sent from the client to the server via a web URL, using one of the **HTTP** methods.

- The server then responds with the requested resource, which could be **HTML, XML, Image, or JSON**, with JSON being the most commonly used format for modern web services.

- These methods map to **CRUD operations (Create, Read, Update, Delete)** for managing resources on the web.

- **Pros**:
  - Simple, language-agnostic, browser-friendly.
  - Great for public APIs and CRUD operations.

- **Cons**:
  - Over-fetching or under-fetching of data.
  - No built-in real-time capabilities.

#### Common HTTP Methods

1. **GET Method**: Used to retrieve data from a server. It is a read-only operation and does not modify any data.
   - Example: Fetching user details from a database.

2. **POST Method**: Used to send data to a server to create a new resource. It is often used for submitting forms or uploading files.
   - Example: Creating a new user account.

3. **PUT Method**: Used to update an existing resource on the server. It replaces the entire resource with the new data provided.
    - Example: Updating user profile information.

4. **DELETE Method**: Used to remove a resource from the server.
    - Example: Deleting a user account.

---

### 2. gRPC (Google Remote Procedure Call)

- **gRPC** is a high-performance, open-source framework developed by Google for remote procedure calls (RPC).  

- It uses **HTTP/2** as the transport protocol and **Protocol Buffers (Protobuf)** as the interface definition language and serialization format.

- **How it Works**:
  1. The client calls a method as if it were a local function.
 
  2. The request is serialized into binary Protobuf format.
 
  3. HTTP/2 streams the request to the server.
 
  4. The server processes the call and returns a Protobuf-encoded response.

- **Key Features**:
  
  - **Bi-directional Streaming**: Client and server can send multiple messages over a single connection simultaneously.
  
  - **Strong Typing**: `.proto` files define service contracts and message structures.
  
  - **Code Generation**: Automatically generates client/server code for many languages (Go, Java, Python, C++, etc.).

- **Pros**:
  
  - Extremely fast and bandwidth-efficient (binary serialization).
  
  - Built-in authentication (TLS), load balancing, and flow control.
  
  - Ideal for **microservices**, **IoT**, and **real-time applications**.

- **Cons**:
  
  - More complex setup than REST (requires `.proto` files and tooling).
  
  - Debugging binary messages is harder than JSON.